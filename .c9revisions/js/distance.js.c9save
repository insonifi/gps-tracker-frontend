{"ts":1379230384386,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/* Vincenty Inverse Solution of Geodesics on the Ellipsoid (c) Chris Veness 2002-2012             */\n/*                                                                                                */\n/* from: Vincenty inverse formula - T Vincenty, \"Direct and Inverse Solutions of Geodesics on the */\n/*       Ellipsoid with application of nested equations\", Survey Review, vol XXII no 176, 1975    */\n/*       http://www.ngs.noaa.gov/PUBS_LIB/inverse.pdf                                             */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/* http://www.movable-type.co.uk/scripts/latlong-vincenty.html \t\t\t\t\t\t\t\t\t  */\n\n/**\n * Calculates geodetic distance between two points specified by latitude/longitude using \n * Vincenty inverse formula for ellipsoids\n *\n * @param   {Number} lat1, lon1: first point in decimal degrees\n * @param   {Number} lat2, lon2: second point in decimal degrees\n * @returns (Number} distance in metres between points\n */\n\ncalculateDistance = function (coordsA, coordsB) {\n    Number.prototype.toRad = function() {\n        return this * Math.PI / 180;\n    }\n  var lat1 = coordsA[0];\n  var lon1 = coordsA[1];\n  var lat2 = coordsB[0];\n  var lon2 = coordsB[1];\n  var a = 6378137, b = 6356752.314245,  f = 1/298.257223563;  // WGS-84 ellipsoid params\n  var L = (lon2-lon1).toRad();\n  var U1 = Math.atan((1-f) * Math.tan(lat1.toRad()));\n  var U2 = Math.atan((1-f) * Math.tan(lat2.toRad()));\n  var sinU1 = Math.sin(U1), cosU1 = Math.cos(U1);\n  var sinU2 = Math.sin(U2), cosU2 = Math.cos(U2);\n  \n  var lambda = L, lambdaP, iterLimit = 100;\n  do {\n    var sinLambda = Math.sin(lambda), cosLambda = Math.cos(lambda);\n    var sinSigma = Math.sqrt((cosU2*sinLambda) * (cosU2*sinLambda) + \n      (cosU1*sinU2-sinU1*cosU2*cosLambda) * (cosU1*sinU2-sinU1*cosU2*cosLambda));\n    if (sinSigma==0) return 0;  // co-incident points\n    var cosSigma = sinU1*sinU2 + cosU1*cosU2*cosLambda;\n    var sigma = Math.atan2(sinSigma, cosSigma);\n    var sinAlpha = cosU1 * cosU2 * sinLambda / sinSigma;\n    var cosSqAlpha = 1 - sinAlpha*sinAlpha;\n    var cos2SigmaM = cosSigma - 2*sinU1*sinU2/cosSqAlpha;\n    if (isNaN(cos2SigmaM)) cos2SigmaM = 0;  // equatorial line: cosSqAlpha=0 (ยง6)\n    var C = f/16*cosSqAlpha*(4+f*(4-3*cosSqAlpha));\n    lambdaP = lambda;\n    lambda = L + (1-C) * f * sinAlpha *\n      (sigma + C*sinSigma*(cos2SigmaM+C*cosSigma*(-1+2*cos2SigmaM*cos2SigmaM)));\n  } while (Math.abs(lambda-lambdaP) > 1e-12 && --iterLimit>0);\n\n  if (iterLimit==0) return NaN  // formula failed to converge\n\n  var uSq = cosSqAlpha * (a*a - b*b) / (b*b);\n  var A = 1 + uSq/16384*(4096+uSq*(-768+uSq*(320-175*uSq)));\n  var B = uSq/1024 * (256+uSq*(-128+uSq*(74-47*uSq)));\n  var deltaSigma = B*sinSigma*(cos2SigmaM+B/4*(cosSigma*(-1+2*cos2SigmaM*cos2SigmaM)-\n    B/6*cos2SigmaM*(-3+4*sinSigma*sinSigma)*(-3+4*cos2SigmaM*cos2SigmaM)));\n  var s = b*A*(sigma-deltaSigma);\n  \n  s = s.toFixed(3); // round to 1mm precision\n  return s;\n  \n  // note: to return initial/final bearings in addition to distance, use something like:\n  var fwdAz = Math.atan2(cosU2*sinLambda,  cosU1*sinU2-sinU1*cosU2*cosLambda);\n  var revAz = Math.atan2(cosU1*sinLambda, -sinU1*cosU2+cosU1*sinU2*cosLambda);\n  return { distance: s, initialBearing: fwdAz.toDeg(), finalBearing: revAz.toDeg() };\n}\n"]],"start1":0,"start2":0,"length1":0,"length2":3429}]],"length":3429}
{"contributors":[],"silentsave":true,"ts":1379234348621,"patch":[[{"diffs":[[0," \n  s = "],[1,"Math.round("],[0,"s.toFixe"]],"start1":3031,"start2":3031,"length1":16,"length2":27}]],"length":3440,"saved":false}
{"ts":1379234353382,"patch":[[{"diffs":[[0,"nd(s"],[-1,".toFixed(3)"],[1,", -"],[0,"; //"]],"start1":3047,"start2":3047,"length1":19,"length2":11}]],"length":3432,"saved":false}
{"ts":1379234354823,"patch":[[{"diffs":[[0,"und(s, -"],[1,"3)"],[0,"; // rou"]],"start1":3046,"start2":3046,"length1":16,"length2":18}]],"length":3434,"saved":false}
{"ts":1379234492513,"patch":[[{"diffs":[[0,"s = "],[-1,"Math.round(s, -"],[1,"s.toFixed("],[0,"3); "]],"start1":3035,"start2":3035,"length1":23,"length2":18}]],"length":3429,"saved":false}
{"ts":1379234493548,"patch":[[{"diffs":[[0," \n  s = "],[1,"+"],[0,"s.toFixe"]],"start1":3031,"start2":3031,"length1":16,"length2":17}]],"length":3430,"saved":false}
