{"ts":1376850745528,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"/*!\n * sly 1.0.1 - 8th Jun 2013\n * https://github.com/Darsain/sly\n *\n * Licensed under the MIT license.\n * http://opensource.org/licenses/MIT\n */\n;(function ($, w, undefined) {\n\t'use strict';\n\n\tvar pluginName = 'sly';\n\tvar className  = 'Sly';\n\tvar namespace  = pluginName;\n\n\t// Local WindowAnimationTiming interface\n\tvar cAF = w.cancelAnimationFrame || w.cancelRequestAnimationFrame;\n\tvar rAF = w.requestAnimationFrame;\n\n\t// Support indicators\n\tvar transform, gpuAcceleration;\n\n\t// Other global values\n\tvar $doc = $(document);\n\tvar dragInitEvents = 'touchstart.' + namespace + ' mousedown.' + namespace;\n\tvar dragMouseEvents = 'mousemove.' + namespace + ' mouseup.' + namespace;\n\tvar dragTouchEvents = 'touchmove.' + namespace + ' touchend.' + namespace;\n\tvar clickEvent = 'click.' + namespace;\n\tvar mouseDownEvent = 'mousedown.' + namespace;\n\n\t/**\n\t * Sly.\n\t *\n\t * @class\n\t *\n\t * @param {Element} frame       DOM element of sly container.\n\t * @param {Object}  options     Object with options.\n\t * @param {Object}  callbackMap Callbacks map.\n\t */\n\tfunction Sly(frame, options, callbackMap) {\n\t\t// Extend options\n\t\tvar o = $.extend({}, Sly.defaults, options);\n\n\t\t// Private variables\n\t\tvar self = this;\n\t\tvar initialized = 0;\n\t\tvar parallax = isNumber(frame);\n\n\t\t// Frame\n\t\tvar $frame = $(frame);\n\t\tvar $slidee = $frame.children().eq(0);\n\t\tvar frameSize = 0;\n\t\tvar slideeSize = 0;\n\t\tvar pos = {\n\t\t\tstart: 0,\n\t\t\tcenter: 0,\n\t\t\tend: 0,\n\t\t\tcur: 0,\n\t\t\tdest: 0\n\t\t};\n\n\t\t// Scrollbar\n\t\tvar $sb = $(o.scrollBar).eq(0);\n\t\tvar $handle = $sb.children().eq(0);\n\t\tvar sbSize = 0;\n\t\tvar handleSize = 0;\n\t\tvar hPos = {\n\t\t\tstart: 0,\n\t\t\tend: 0,\n\t\t\tcur: 0\n\t\t};\n\n\t\t// Pagesbar\n\t\tvar $pb = $(o.pagesBar);\n\t\tvar $pages = 0;\n\t\tvar pages = [];\n\n\t\t// Items\n\t\tvar $items = 0;\n\t\tvar items = [];\n\t\tvar rel = {\n\t\t\tfirstItem: 0,\n\t\t\tlastItem: 0,\n\t\t\tcenterItem: 0,\n\t\t\tactiveItem: -1,\n\t\t\tactivePage: 0\n\t\t};\n\n\t\t// Navigation type booleans\n\t\tvar basicNav = o.itemNav === 'basic';\n\t\tvar forceCenteredNav = o.itemNav === 'forceCentered';\n\t\tvar centeredNav = o.itemNav === 'centered' || forceCenteredNav;\n\t\tvar itemNav = !parallax && (basicNav || centeredNav || forceCenteredNav);\n\n\t\t// Miscellaneous\n\t\tvar $scrollSource = o.scrollSource ? $(o.scrollSource) : $frame;\n\t\tvar $dragSource = o.dragSource ? $(o.dragSource) : $frame;\n\t\tvar $forwardButton = $(o.forward);\n\t\tvar $backwardButton = $(o.backward);\n\t\tvar $prevButton = $(o.prev);\n\t\tvar $nextButton = $(o.next);\n\t\tvar $prevPageButton = $(o.prevPage);\n\t\tvar $nextPageButton = $(o.nextPage);\n\t\tvar callbacks = {};\n\t\tvar last = {};\n\t\tvar animation = {};\n\t\tvar move = {};\n\t\tvar dragging = { released: 1 };\n\t\tvar renderID = 0;\n\t\tvar historyID = 0;\n\t\tvar cycleID = 0;\n\t\tvar continuousID = 0;\n\t\tvar i, l;\n\n\t\t// Normalizing frame\n\t\tif (!parallax) {\n\t\t\tframe = $frame[0];\n\t\t}\n\n\t\t// Expose properties\n\t\tself.frame = frame;\n\t\tself.slidee = $slidee[0];\n\t\tself.pos = pos;\n\t\tself.rel = rel;\n\t\tself.items = items;\n\t\tself.pages = pages;\n\t\tself.isPaused = 0;\n\t\tself.options = o;\n\n\t\t/**\n\t\t * (Re)Loading function.\n\t\t *\n\t\t * Populate arrays, set sizes, bind events, ...\n\t\t *\n\t\t * @return {Void}\n\t\t */\n\t\tfunction load() {\n\t\t\t// Local variables\n\t\t\tvar ignoredMargin = 0;\n\n\t\t\t// Save old position\n\t\t\tpos.old = $.extend({}, pos);\n\n\t\t\t// Reset global variables\n\t\t\tframeSize = parallax ? 0 : $frame[o.horizontal ? 'width' : 'height']();\n\t\t\tsbSize = $sb[o.horizontal ? 'width' : 'height']();\n\t\t\tslideeSize = parallax ? frame : $slidee[o.horizontal ? 'outerWidth' : 'outerHeight']();\n\t\t\tpages.length = 0;\n\n\t\t\t// Set position limits & relatives\n\t\t\tpos.start = 0;\n\t\t\tpos.end = Math.max(slideeSize - frameSize, 0);\n\t\t\tlast = {};\n\n\t\t\t// Sizes & offsets for item based navigations\n\t\t\tif (itemNav) {\n\t\t\t\t// Save the number of current items\n\t\t\t\tvar lastItemsCount = items.length;\n\n\t\t\t\t// Reset itemNav related variables\n\t\t\t\t$items = $slidee.children(o.itemSelector);\n\t\t\t\titems.length = 0;\n\n\t\t\t\t// Needed variables\n\t\t\t\tvar paddingStart = getPx($slidee, o.horizontal ? 'paddingLeft' : 'paddingTop');\n\t\t\t\tvar paddingEnd = getPx($slidee, o.horizontal ? 'paddingRight' : 'paddingBottom');\n\t\t\t\tvar marginStart = getPx($items, o.horizontal ? 'marginLeft' : 'marginTop');\n\t\t\t\tvar marginEnd = getPx($items.slice(-1), o.horizontal ? 'marginRight' : 'marginBottom');\n\t\t\t\tvar centerOffset = 0;\n\t\t\t\tvar areFloated = $items.css('float') !== 'none';\n\n\t\t\t\t// Update ignored margin\n\t\t\t\tignoredMargin = marginStart ? 0 : marginEnd;\n\n\t\t\t\t// Reset slideeSize\n\t\t\t\tslideeSize = 0;\n\n\t\t\t\t// Iterate through items\n\t\t\t\t$items.each(function (i, element) {\n\t\t\t\t\t// Item\n\t\t\t\t\tvar $item = $(element);\n\t\t\t\t\tvar itemSize = $item[o.horizontal ? 'outerWidth' : 'outerHeight'](true);\n\t\t\t\t\tvar itemMarginStart = getPx($item, o.horizontal ? 'marginLeft' : 'marginTop');\n\t\t\t\t\tvar itemMarginEnd = getPx($item, o.horizontal ? 'marginRight' : 'marginBottom');\n\t\t\t\t\tvar itemData = {\n\t\t\t\t\t\tel: element,\n\t\t\t\t\t\tsize: itemSize,\n\t\t\t\t\t\thalf: itemSize / 2,\n\t\t\t\t\t\tstart: slideeSize - (!i || o.horizontal ? 0 : itemMarginStart),\n\t\t\t\t\t\tcenter: slideeSize - Math.round(frameSize / 2 - itemSize / 2),\n\t\t\t\t\t\tend: slideeSize - frameSize + itemSize - (marginStart ? 0 : itemMarginEnd)\n\t\t\t\t\t};\n\n\t\t\t\t\t// Account for centerOffset & slidee padding\n\t\t\t\t\tif (!i) {\n\t\t\t\t\t\tcenterOffset = -(forceCenteredNav ? Math.round(frameSize / 2 - itemSize / 2) : 0) + paddingStart;\n\t\t\t\t\t\tslideeSize += paddingStart;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Increment slidee size for size of the active element\n\t\t\t\t\tslideeSize += itemSize;\n\n\t\t\t\t\t// Try to account for vertical margin collapsing in vertical mode\n\t\t\t\t\t// It's not bulletproof, but should work in 99% of cases\n\t\t\t\t\tif (!o.horizontal && !areFloated) {\n\t\t\t\t\t\t// Subtract smaller margin, but only when top margin is not 0, and this is not the first element\n\t\t\t\t\t\tif (itemMarginEnd && itemMarginStart && i > 0) {\n\t\t\t\t\t\t\tslideeSize -= Math.min(itemMarginStart, itemMarginEnd);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Things to be done on last item\n\t\t\t\t\tif (i === $items.length - 1) {\n\t\t\t\t\t\tslideeSize += paddingEnd;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Add item object to items array\n\t\t\t\t\titems.push(itemData);\n\t\t\t\t});\n\n\t\t\t\t// Resize SLIDEE to fit all items\n\t\t\t\t$slidee[0].style[o.horizontal ? 'width' : 'height'] = slideeSize + 'px';\n\n\t\t\t\t// Adjust internal SLIDEE size for last margin\n\t\t\t\tslideeSize -= ignoredMargin;\n\n\t\t\t\t// Set limits\n\t\t\t\tpos.start = centerOffset;\n\t\t\t\tpos.end = forceCenteredNav ? (items.length ? items[items.length - 1].center : centerOffset) : Math.max(slideeSize - frameSize, 0);\n\n\t\t\t\t// Activate last item if previous active has been removed, or first item\n\t\t\t\t// when there were no items before, and new got appended.\n\t\t\t\tif (rel.activeItem >= items.length || lastItemsCount === 0 && items.length > 0) {\n\t\t\t\t\tactivate(items.length > 0 ? items.length - 1 : 0);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Calculate SLIDEE center position\n\t\t\tpos.center = Math.round(pos.end / 2 + pos.start / 2);\n\n\t\t\t// Update relative positions\n\t\t\tupdateRelatives();\n\n\t\t\t// Scrollbar\n\t\t\tif ($handle.length && sbSize > 0) {\n\t\t\t\t// Stretch scrollbar handle to represent the visible area\n\t\t\t\tif (o.dynamicHandle) {\n\t\t\t\t\t// ForceCentered navigation edge case\n\t\t\t\t\tif (forceCenteredNav) {\n\t\t\t\t\t\thandleSize = items.length ? sbSize * frameSize / (frameSize + items[items.length-1].center - items[0].center) : sbSize;\n\t\t\t\t\t} else {\n\t\t\t\t\t\thandleSize = sbSize * frameSize / slideeSize;\n\t\t\t\t\t}\n\t\t\t\t\thandleSize = within(Math.round(handleSize), o.minHandleSize, sbSize);\n\t\t\t\t\t$handle[0].style[o.horizontal ? 'width' : 'height'] = handleSize + 'px';\n\t\t\t\t} else {\n\t\t\t\t\thandleSize = $handle[o.horizontal ? 'outerWidth' : 'outerHeight']();\n\t\t\t\t}\n\n\t\t\t\thPos.end = sbSize - handleSize;\n\n\t\t\t\tif (!renderID) {\n\t\t\t\t\tsyncScrollbar();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Pages\n\t\t\tif (!parallax && frameSize > 0) {\n\t\t\t\tvar tempPagePos = pos.start;\n\t\t\t\tvar pagesHtml = '';\n\n\t\t\t\t// Populate pages array\n\t\t\t\tif (itemNav) {\n\t\t\t\t\t$.each(items, function (i, item) {\n\t\t\t\t\t\tif (forceCenteredNav || item.start + item.size > tempPagePos) {\n\t\t\t\t\t\t\ttempPagePos = item[forceCenteredNav ? 'center' : 'start'];\n\t\t\t\t\t\t\tpages.push(tempPagePos);\n\t\t\t\t\t\t\ttempPagePos += frameSize;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\twhile (tempPagePos - frameSize < pos.end) {\n\t\t\t\t\t\tpages.push(tempPagePos);\n\t\t\t\t\t\ttempPagePos += frameSize;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Pages bar\n\t\t\t\tif ($pb[0]) {\n\t\t\t\t\tfor (var i = 0; i < pages.length; i++) {\n\t\t\t\t\t\tpagesHtml += o.pageBuilder.call(self, i);\n\t\t\t\t\t}\n\t\t\t\t\t$pages = $pb.html(pagesHtml).children();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Fix possible overflowing\n\t\t\tslideTo(within(pos.dest, pos.start, pos.end));\n\n\t\t\t// Extend relative variables object with some useful info\n\t\t\trel.slideeSize = slideeSize;\n\t\t\trel.frameSize = frameSize;\n\t\t\trel.sbSize = sbSize;\n\t\t\trel.handleSize = handleSize;\n\n\t\t\t// Trigger load event\n\t\t\ttrigger('load');\n\t\t}\n\t\tself.reload = load;\n\n\t\t/**\n\t\t * Animate to a position.\n\t\t *\n\t\t * @param {Int}  newPos    New position.\n\t\t * @param {Bool} immediate Reposition immediately without an animation.\n\t\t * @param {Bool} dontAlign Do not align items, use the raw position passed in first argument.\n\t\t *\n\t\t * @return {Void}\n\t\t */\n\t\tfunction slideTo(newPos, immediate, dontAlign) {\n\t\t\t// Align items\n\t\t\tif (itemNav && dragging.released && !dontAlign) {\n\t\t\t\tvar tempRel = getRelatives(newPos);\n\t\t\t\tvar isNotBordering = newPos > pos.start && newPos < pos.end;\n\n\t\t\t\tif (centeredNav) {\n\t\t\t\t\tif (isNotBordering) {\n\t\t\t\t\t\tnewPos = items[tempRel.centerItem].center;\n\t\t\t\t\t}\n\t\t\t\t\tif (forceCenteredNav && o.activateMiddle) {\n\t\t\t\t\t\tactivate(tempRel.centerItem);\n\t\t\t\t\t}\n\t\t\t\t} else if (isNotBordering) {\n\t\t\t\t\tnewPos = items[tempRel.firstItem].start;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Handle overflowing position limits\n\t\t\tif (dragging.init && dragging.slidee && o.elasticBounds) {\n\t\t\t\tif (newPos > pos.end) {\n\t\t\t\t\tnewPos = pos.end + (newPos - pos.end) / 6;\n\t\t\t\t} else if (newPos < pos.start) {\n\t\t\t\t\tnewPos = pos.start + (newPos - pos.start) / 6;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tnewPos = within(newPos, pos.start, pos.end);\n\t\t\t}\n\n\t\t\t// Update the animation object\n\t\t\tanimation.start = +new Date();\n\t\t\tanimation.time = 0;\n\t\t\tanimation.from = pos.cur;\n\t\t\tanimation.to = newPos;\n\t\t\tanimation.delta = newPos - pos.cur;\n\t\t\tanimation.tweesing = dragging.tweese || dragging.init && !dragging.slidee;\n\t\t\tanimation.immediate = immediate || dragging.init && dragging.slidee && !dragging.tweese;\n\n\t\t\t// Reset dragging tweesing request\n\t\t\tdragging.tweese = 0;\n\n\t\t\t// Start animation rendering\n\t\t\tif (newPos !== pos.dest) {\n\t\t\t\tpos.dest = newPos;\n\t\t\t\ttrigger('change');\n\t\t\t\tif (!renderID) {\n\t\t\t\t\trender();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Reset next cycle timeout\n\t\t\tresetCycle();\n\n\t\t\t// Synchronize states\n\t\t\tupdateRelatives();\n\t\t\tupdateButtonsState();\n\t\t\tsyncPagesbar();\n\t\t}\n\n\t\t/**\n\t\t * Render animation frame.\n\t\t *\n\t\t * @return {Void}\n\t\t */\n\t\tfunction render() {\n\t\t\t// If first render call, wait for next animationFrame\n\t\t\tif (!renderID) {\n\t\t\t\trenderID = rAF(render);\n\t\t\t\tif (dragging.released) {\n\t\t\t\t\ttrigger('moveStart');\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// If immediate repositioning is requested, don't animate.\n\t\t\tif (animation.immediate) {\n\t\t\t\tpos.cur = animation.to;\n\t\t\t}\n\t\t\t// Use tweesing for animations without known end point\n\t\t\telse if (animation.tweesing) {\n\t\t\t\tanimation.tweeseDelta = animation.to - pos.cur;\n\t\t\t\t// Fuck Zeno's paradox\n\t\t\t\tif (Math.abs(animation.tweeseDelta) < 0.1) {\n\t\t\t\t\tpos.cur = animation.to;\n\t\t\t\t} else {\n\t\t\t\t\tpos.cur += animation.tweeseDelta * (dragging.released ? o.swingSpeed : o.syncSpeed);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Use tweening for basic animations with known end point\n\t\t\telse {\n\t\t\t\tanimation.time = Math.min(+new Date() - animation.start, o.speed);\n\t\t\t\tpos.cur = animation.from + animation.delta * jQuery.easing[o.easing](animation.time/o.speed, animation.time, 0, 1, o.speed);\n\t\t\t}\n\n\t\t\t// If there is nothing more to render break the rendering loop, otherwise request new animation frame.\n\t\t\tif (animation.to === pos.cur) {\n\t\t\t\tpos.cur = animation.to;\n\t\t\t\tdragging.tweese = renderID = 0;\n\t\t\t} else {\n\t\t\t\trenderID = rAF(render);\n\t\t\t}\n\n\t\t\ttrigger('move');\n\n\t\t\t// Update SLIDEE position\n\t\t\tif (!parallax) {\n\t\t\t\tif (transform) {\n\t\t\t\t\t$slidee[0].style[transform] = gpuAcceleration + (o.horizontal ? 'translateX' : 'translateY') + '(' + (-pos.cur) + 'px)';\n\t\t\t\t} else {\n\t\t\t\t\t$slidee[0].style[o.horizontal ? 'left' : 'top'] = -Math.round(pos.cur) + 'px';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// When animation reached the end, and dragging is not active, trigger moveEnd\n\t\t\tif (!renderID && dragging.released) {\n\t\t\t\ttrigger('moveEnd');\n\t\t\t}\n\n\t\t\tsyncScrollbar();\n\t\t}\n\n\t\t/**\n\t\t * Synchronizes scrollbar with the SLIDEE.\n\t\t *\n\t\t * @return {Void}\n\t\t */\n\t\tfunction syncScrollbar() {\n\t\t\tif ($handle.length) {\n\t\t\t\thPos.cur = pos.start === pos.end ? 0 : (((dragging.init && !dragging.slidee) ? pos.dest : pos.cur) - pos.start) / (pos.end - pos.start) * hPos.end;\n\t\t\t\thPos.cur = within(Math.round(hPos.cur), hPos.start, hPos.end);\n\t\t\t\tif (last.hPos !== hPos.cur) {\n\t\t\t\t\tlast.hPos = hPos.cur;\n\t\t\t\t\tif (transform) {\n\t\t\t\t\t\t$handle[0].style[transform] = gpuAcceleration + (o.horizontal ? 'translateX' : 'translateY') + '(' + hPos.cur + 'px)';\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$handle[0].style[o.horizontal ? 'left' : 'top'] = hPos.cur + 'px';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Synchronizes pagesbar with SLIDEE.\n\t\t *\n\t\t * @return {Void}\n\t\t */\n\t\tfunction syncPagesbar() {\n\t\t\tif ($pages[0] && last.page !== rel.activePage) {\n\t\t\t\tlast.page = rel.activePage;\n\t\t\t\t$pages.removeClass(o.activeClass).eq(rel.activePage).addClass(o.activeClass);\n\t\t\t\ttrigger('activePage', last.page);\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Returns the position object.\n\t\t *\n\t\t * @param {Mixed} item\n\t\t *\n\t\t * @return {Object}\n\t\t */\n\t\tself.getPos = function (item) {\n\t\t\tif (itemNav) {\n\t\t\t\tvar index = getIndex(item);\n\t\t\t\treturn index !== -1 ? items[index] : false;\n\t\t\t} else {\n\t\t\t\tvar $item = $slidee.find(item).eq(0);\n\n\t\t\t\tif ($item[0]) {\n\t\t\t\t\tvar offset = o.horizontal ? $item.offset().left - $slidee.offset().left : $item.offset().top - $slidee.offset().top;\n\t\t\t\t\tvar size = $item[o.horizontal ? 'outerWidth' : 'outerHeight']();\n\n\t\t\t\t\treturn {\n\t\t\t\t\t\tstart: offset,\n\t\t\t\t\t\tcenter: offset - frameSize / 2 + size / 2,\n\t\t\t\t\t\tend: offset - frameSize + size,\n\t\t\t\t\t\tsize: size\n\t\t\t\t\t};\n\t\t\t\t} else {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Continuous move in a specified direction.\n\t\t *\n\t\t * @param  {Bool} forward True for forward movement, otherwise it'll go backwards.\n\t\t * @param  {Int}  speed   Movement speed in pixels per frame. Overrides options.moveBy value.\n\t\t *\n\t\t * @return {Void}\n\t\t */\n\t\tself.moveBy = function (speed) {\n\t\t\tmove.speed = speed;\n\t\t\t// If already initiated, or there is nowhere to move, abort\n\t\t\tif (dragging.init || !move.speed || pos.cur === (move.speed > 0 ? pos.end : pos.start)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// Initiate move object\n\t\t\tmove.lastTime = +new Date();\n\t\t\tmove.startPos = pos.cur;\n\t\t\t// Set dragging as initiated\n\t\t\tcontinuousInit('button');\n\t\t\tdragging.init = 1;\n\t\t\t// Start movement\n\t\t\ttrigger('moveStart');\n\t\t\tcAF(continuousID);\n\t\t\tmoveLoop();\n\t\t};\n\n\t\t/**\n\t\t * Continuous movement loop.\n\t\t *\n\t\t * @return {Void}\n\t\t */\n\t\tfunction moveLoop() {\n\t\t\t// If there is nowhere to move anymore, stop\n\t\t\tif (!move.speed || pos.cur === (move.speed > 0 ? pos.end : pos.start)) {\n\t\t\t\tself.stop();\n\t\t\t}\n\t\t\t// Request new move loop if it hasn't been stopped\n\t\t\tcontinuousID = dragging.init ? rAF(moveLoop) : 0;\n\t\t\t// Update move object\n\t\t\tmove.now = +new Date();\n\t\t\tmove.pos = pos.cur + (move.now - move.lastTime) / 1000 * move.speed;\n\t\t\t// Slide\n\t\t\tslideTo(dragging.init ? move.pos : Math.round(move.pos));\n\t\t\t// Normally, this is triggered in render(), but if there\n\t\t\t// is nothing to render, we have to do it manually here.\n\t\t\tif (!dragging.init && pos.cur === pos.dest) {\n\t\t\t\ttrigger('moveEnd');\n\t\t\t}\n\t\t\t// Update times for future iteration\n\t\t\tmove.lastTime = move.now;\n\t\t}\n\n\t\t/**\n\t\t * Stops continuous movement.\n\t\t *\n\t\t * @return {Void}\n\t\t */\n\t\tself.stop = function () {\n\t\t\tif (dragging.source === 'button') {\n\t\t\t\tdragging.init = 0;\n\t\t\t\tdragging.released = 1;\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Activate previous item.\n\t\t *\n\t\t * @return {Void}\n\t\t */\n\t\tself.prev = function () {\n\t\t\tself.activate(rel.activeItem - 1);\n\t\t};\n\n\t\t/**\n\t\t * Activate next item.\n\t\t *\n\t\t * @return {Void}\n\t\t */\n\t\tself.next = function () {\n\t\t\tself.activate(rel.activeItem + 1);\n\t\t};\n\n\t\t/**\n\t\t * Activate previous page.\n\t\t *\n\t\t * @return {Void}\n\t\t */\n\t\tself.prevPage = function () {\n\t\t\tself.activatePage(rel.activePage - 1);\n\t\t};\n\n\t\t/**\n\t\t * Activate next page.\n\t\t *\n\t\t * @return {Void}\n\t\t */\n\t\tself.nextPage = function () {\n\t\t\tself.activatePage(rel.activePage + 1);\n\t\t};\n\n\t\t/**\n\t\t * Slide SLIDEE by amount of pixels.\n\t\t *\n\t\t * @param {Int}  delta     Difference in position. Positive means forward, negative means backward.\n\t\t * @param {Bool} immediate Reposition immediately without an animation.\n\t\t *\n\t\t * @return {Void}\n\t\t */\n\t\tself.slideBy = function (delta, immediate) {\n\t\t\tslideTo(pos.dest + delta, immediate);\n\t\t};\n\n\t\t/**\n\t\t * Animate SLIDEE to a specific position.\n\t\t *\n\t\t * @param {Int}  pos       New position.\n\t\t * @param {Bool} immediate Reposition immediately without an animation.\n\t\t *\n\t\t * @return {Void}\n\t\t */\n\t\tself.slideTo = function (pos, immediate) {\n\t\t\tslideTo(pos, immediate);\n\t\t};\n\n\t\t/**\n\t\t * Core method for handling `toLocation` methods.\n\t\t *\n\t\t * @param  {String} location\n\t\t * @param  {Mixed}  item\n\t\t * @param  {Bool}   immediate\n\t\t *\n\t\t * @return {Void}\n\t\t */\n\t\tfunction to(location, item, immediate) {\n\t\t\t// Optional arguments logic\n\t\t\tif (type(item) === 'boolean') {\n\t\t\t\timmediate = item;\n\t\t\t\titem = undefined;\n\t\t\t}\n\n\t\t\tif (item === undefined) {\n\t\t\t\tslideTo(pos[location], immediate);\n\t\t\t} else {\n\t\t\t\t// You can't align items to sides of the frame\n\t\t\t\t// when centered navigation type is enabled\n\t\t\t\tif (centeredNav && location !== 'center') {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tvar itemPos = self.getPos(item);\n\t\t\t\tif (itemPos) {\n\t\t\t\t\tslideTo(itemPos[location], immediate, !centeredNav);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Animate element or the whole SLIDEE to the start of the frame.\n\t\t *\n\t\t * @param {Mixed} item      Item DOM element, or index starting at 0. Omitting will animate SLIDEE.\n\t\t * @param {Bool}  immediate Reposition immediately without an animation.\n\t\t *\n\t\t * @return {Void}\n\t\t */\n\t\tself.toStart = function (item, immediate) {\n\t\t\tto('start', item, immediate);\n\t\t};\n\n\t\t/**\n\t\t * Animate element or the whole SLIDEE to the end of the frame.\n\t\t *\n\t\t * @param {Mixed} item      Item DOM element, or index starting at 0. Omitting will animate SLIDEE.\n\t\t * @param {Bool}  immediate Reposition immediately without an animation.\n\t\t *\n\t\t * @return {Void}\n\t\t */\n\t\tself.toEnd = function (item, immediate) {\n\t\t\tto('end', item, immediate);\n\t\t};\n\n\t\t/**\n\t\t * Animate element or the whole SLIDEE to the center of the frame.\n\t\t *\n\t\t * @param {Mixed} item      Item DOM element, or index starting at 0. Omitting will animate SLIDEE.\n\t\t * @param {Bool}  immediate Reposition immediately without an animation.\n\t\t *\n\t\t * @return {Void}\n\t\t */\n\t\tself.toCenter = function (item, immediate) {\n\t\t\tto('center', item, immediate);\n\t\t};\n\n\t\t/**\n\t\t * Get the index of an item in SLIDEE.\n\t\t *\n\t\t * @param {Mixed} item     Item DOM element.\n\t\t *\n\t\t * @return {Int}  Item index, or -1 if not found.\n\t\t */\n\t\tfunction getIndex(item) {\n\t\t\treturn type(item) !== 'undefined' ?\n\t\t\t\t\tisNumber(item) ?\n\t\t\t\t\t\titem >= 0 && item < items.length ? item : -1 :\n\t\t\t\t\t\t$items.index(item) :\n\t\t\t\t\t-1;\n\t\t}\n\t\t// Expose getIndex without lowering the compressibility of it,\n\t\t// as it is used quite often throughout Sly.\n\t\tself.getIndex = getIndex;\n\n\t\t/**\n\t\t * Get index of an item in SLIDEE based on a variety of input types.\n\t\t *\n\t\t * @param  {Mixed} item DOM element, positive or negative integer.\n\t\t *\n\t\t * @return {Int}   Item index, or -1 if not found.\n\t\t */\n\t\tfunction getRelativeIndex(item) {\n\t\t\treturn getIndex(isNumber(item) && item < 0 ? item + items.length : item);\n\t\t}\n\n\t\t/**\n\t\t * Activates an item.\n\t\t *\n\t\t * @param  {Mixed} item Item DOM element, or index starting at 0.\n\t\t *\n\t\t * @return {Mixed} Activated item index or false on fail.\n\t\t */\n\t\tfunction activate(item) {\n\t\t\tvar index = getIndex(item);\n\n\t\t\tif (!itemNav || index < 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// Update classes, last active index, and trigger active event only when there\n\t\t\t// has been a change. Otherwise just return the current active index.\n\t\t\tif (last.active !== index) {\n\t\t\t\t// Update classes\n\t\t\t\t$items.eq(rel.activeItem).removeClass(o.activeClass);\n\t\t\t\t$items.eq(index).addClass(o.activeClass);\n\n\t\t\t\tlast.active = rel.activeItem = index;\n\n\t\t\t\tupdateButtonsState();\n\t\t\t\ttrigger('active', index);\n\t\t\t}\n\n\t\t\treturn index;\n\t\t}\n\n\t\t/**\n\t\t * Activates an item and helps with further navigation when o.smart is enabled.\n\t\t *\n\t\t * @param {Mixed} item      Item DOM element, or index starting at 0.\n\t\t * @param {Bool}  immediate Whether to reposition immediately in smart navigation.\n\t\t *\n\t\t * @return {Void}\n\t\t */\n\t\tself.activate = function (item, immediate) {\n\t\t\tvar index = activate(item);\n\n\t\t\t// Smart navigation\n\t\t\tif (o.smart && index !== false) {\n\t\t\t\t// When centeredNav is enabled, center the element.\n\t\t\t\t// Otherwise, determine where to position the element based on its current position.\n\t\t\t\t// If the element is currently on the far end side of the frame, assume that user is\n\t\t\t\t// moving forward and animate it to the start of the visible frame, and vice versa.\n\t\t\t\tif (centeredNav) {\n\t\t\t\t\tself.toCenter(index, immediate);\n\t\t\t\t} else if (index >= rel.lastItem) {\n\t\t\t\t\tself.toStart(index, immediate);\n\t\t\t\t} else if (index <= rel.firstItem) {\n\t\t\t\t\tself.toEnd(index, immediate);\n\t\t\t\t} else {\n\t\t\t\t\tresetCycle();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Activates a page.\n\t\t *\n\t\t * @param {Int}  index     Page index, starting from 0.\n\t\t * @param {Bool} immediate Whether to reposition immediately without animation.\n\t\t *\n\t\t * @return {Void}\n\t\t */\n\t\tself.activatePage = function (index, immediate) {\n\t\t\tif (isNumber(index)) {\n\t\t\t\tslideTo(pages[within(index, 0, pages.length - 1)], immediate);\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Return relative positions of items based on their visibility within FRAME.\n\t\t *\n\t\t * @param {Int} slideePos Position of SLIDEE.\n\t\t *\n\t\t * @return {Void}\n\t\t */\n\t\tfunction getRelatives(slideePos) {\n\t\t\tslideePos = within(isNumber(slideePos) ? slideePos : pos.dest, pos.start, pos.end);\n\n\t\t\tvar relatives = {};\n\t\t\tvar centerOffset = forceCenteredNav ? 0 : frameSize / 2;\n\n\t\t\t// Determine active page\n\t\t\tif (!parallax) {\n\t\t\t\tfor (var p = 0, pl = pages.length; p < pl; p++) {\n\t\t\t\t\tif (slideePos >= pos.end || p === pages.length - 1) {\n\t\t\t\t\t\trelatives.activePage = pages.length - 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (slideePos <= pages[p] + centerOffset) {\n\t\t\t\t\t\trelatives.activePage = p;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Relative item indexes\n\t\t\tif (itemNav) {\n\t\t\t\tvar first = false;\n\t\t\t\tvar last = false;\n\t\t\t\tvar center = false;\n\n\t\t\t\t// From start\n\t\t\t\tfor (var i = 0, il = items.length; i < il; i++) {\n\t\t\t\t\t// First item\n\t\t\t\t\tif (first === false && slideePos <= items[i].start + items[i].half) {\n\t\t\t\t\t\tfirst = i;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Center item\n\t\t\t\t\tif (center === false && slideePos <= items[i].center + items[i].half) {\n\t\t\t\t\t\tcenter = i;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Last item\n\t\t\t\t\tif (i === il - 1 || slideePos <= items[i].end + items[i].half) {\n\t\t\t\t\t\tlast = i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Safe assignment, just to be sure the false won't be returned\n\t\t\t\trelatives.firstItem = isNumber(first) ? first : 0;\n\t\t\t\trelatives.centerItem = isNumber(center) ? center : relatives.firstItem;\n\t\t\t\trelatives.lastItem = isNumber(last) ? last : relatives.centerItem;\n\t\t\t}\n\n\t\t\treturn relatives;\n\t\t}\n\n\t\t/**\n\t\t * Update object with relative positions.\n\t\t *\n\t\t * @param {Int} newPos\n\t\t *\n\t\t * @return {Void}\n\t\t */\n\t\tfunction updateRelatives(newPos) {\n\t\t\t$.extend(rel, getRelatives(newPos));\n\t\t}\n\n\t\t/**\n\t\t * Disable navigation buttons when needed.\n\t\t *\n\t\t * Adds disabledClass, and when the button is <button> or <input>, activates :disabled state.\n\t\t *\n\t\t * @return {Void}\n\t\t */\n\t\tfunction updateButtonsState() {\n\t\t\tvar isStart = pos.dest <= pos.start;\n\t\t\tvar isEnd = pos.dest >= pos.end;\n\t\t\tvar slideePosState = isStart ? 1 : isEnd ? 2 : 3;\n\n\t\t\t// Update paging buttons only if there has been a change in SLIDEE position\n\t\t\tif (last.slideePosState !== slideePosState) {\n\t\t\t\tlast.slideePosState = slideePosState;\n\n\t\t\t\tif ($prevPageButton.is('button,input')) {\n\t\t\t\t\t$prevPageButton.prop('disabled', isStart);\n\t\t\t\t}\n\n\t\t\t\tif ($nextPageButton.is('button,input')) {\n\t\t\t\t\t$nextPageButton.prop('disabled', isEnd);\n\t\t\t\t}\n\n\t\t\t\t$prevPageButton.add($backwardButton)[isStart ? 'addClass' : 'removeClass'](o.disabledClass);\n\t\t\t\t$nextPageButton.add($forwardButton)[isEnd ? 'addClass' : 'removeClass'](o.disabledClass);\n\t\t\t}\n\n\t\t\t// Forward & Backward buttons need a separate state caching because we cannot \"property disable\"\n\t\t\t// them while they are being used, as disabled buttons stop emitting mouse events.\n\t\t\tif (last.fwdbwdState !== slideePosState && dragging.released) {\n\t\t\t\tlast.fwdbwdState = slideePosState;\n\n\t\t\t\tif ($backwardButton.is('button,input')) {\n\t\t\t\t\t$backwardButton.prop('disabled', isStart);\n\t\t\t\t}\n\n\t\t\t\tif ($forwardButton.is('button,input')) {\n\t\t\t\t\t$forwardButton.prop('disabled', isEnd);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Item navigation\n\t\t\tif (itemNav) {\n\t\t\t\tvar isFirst = rel.activeItem === 0;\n\t\t\t\tvar isLast = rel.activeItem >= items.length - 1;\n\t\t\t\tvar itemsButtonState = isFirst ? 1 : isLast ? 2 : 3;\n\n\t\t\t\tif (last.itemsButtonState !== itemsButtonState) {\n\t\t\t\t\tlast.itemsButtonState = itemsButtonState;\n\n\t\t\t\t\tif ($prevButton.is('button,input')) {\n\t\t\t\t\t\t$prevButton.prop('disabled', isFirst);\n\t\t\t\t\t}\n\n\t\t\t\t\tif ($nextButton.is('button,input')) {\n\t\t\t\t\t\t$nextButton.prop('disabled', isLast);\n\t\t\t\t\t}\n\n\t\t\t\t\t$prevButton[isFirst ? 'addClass' : 'removeClass'](o.disabledClass);\n\t\t\t\t\t$nextButton[isLast ? 'addClass' : 'removeClass'](o.disabledClass);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Resume cycling.\n\t\t *\n\t\t * @param {Int} priority Resume pause with priority lower or equal than this. Used internally for pauseOnHover.\n\t\t *\n\t\t * @return {Void}\n\t\t */\n\t\tself.resume = function (priority) {\n\t\t\tif (!o.cycleBy || !o.cycleInterval || o.cycleBy === 'items' && !items[0] || priority < self.isPaused) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tself.isPaused = 0;\n\n\t\t\tif (cycleID) {\n\t\t\t\tcycleID = clearTimeout(cycleID);\n\t\t\t} else {\n\t\t\t\ttrigger('resume');\n\t\t\t}\n\n\t\t\tcycleID = setTimeout(function () {\n\t\t\t\ttrigger('cycle');\n\t\t\t\tswitch (o.cycleBy) {\n\t\t\t\t\tcase 'items':\n\t\t\t\t\t\tself.activate(rel.activeItem >= items.length - 1 ? 0 : rel.activeItem + 1);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'pages':\n\t\t\t\t\t\tself.activatePage(rel.activePage >= pages.length - 1 ? 0 : rel.activePage + 1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}, o.cycleInterval);\n\t\t};\n\n\t\t/**\n\t\t * Pause cycling.\n\t\t *\n\t\t * @param {Int} priority Pause priority. 100 is default. Used internally for pauseOnHover.\n\t\t *\n\t\t * @return {Void}\n\t\t */\n\t\tself.pause = function (priority) {\n\t\t\tif (priority < self.isPaused) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tself.isPaused = priority || 100;\n\n\t\t\tif (cycleID) {\n\t\t\t\tcycleID = clearTimeout(cycleID);\n\t\t\t\ttrigger('pause');\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Toggle cycling.\n\t\t *\n\t\t * @return {Void}\n\t\t */\n\t\tself.toggle = function () {\n\t\t\tself[cycleID ? 'pause' : 'resume']();\n\t\t};\n\n\t\t/**\n\t\t * Updates a signle or multiple option values.\n\t\t *\n\t\t * @param {Mixed} name  Name of the option that should be updated, or object that will extend the options.\n\t\t * @param {Mixed} value New option value.\n\t\t *\n\t\t * @return {Void}\n\t\t */\n\t\tself.set = function (name, value) {\n\t\t\tif ($.isPlainObject(name)) {\n\t\t\t\t$.extend(o, name);\n\t\t\t} else if (o.hasOwnProperty(name)) {\n\t\t\t\to[name] = value;\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Add one or multiple items to the SLIDEE end, or a specified position index.\n\t\t *\n\t\t * @param {Mixed} element Node element, or HTML string.\n\t\t * @param {Int}   index   Index of a new item position. By default item is appended at the end.\n\t\t *\n\t\t * @return {Void}\n\t\t */\n\t\tself.add = function (element, index) {\n\t\t\tvar $element = $(element);\n\n\t\t\tif (itemNav) {\n\t\t\t\t// Insert the element(s)\n\t\t\t\tif (type(index) === 'undefined' || !items[0]) {\n\t\t\t\t\t$element.appendTo($slidee);\n\t\t\t\t} else if (items.length) {\n\t\t\t\t\t$element.insertBefore(items[index].el);\n\t\t\t\t}\n\n\t\t\t\t// Adjust the activeItem index\n\t\t\t\tif (index <= rel.activeItem) {\n\t\t\t\t\tlast.active = rel.activeItem += $element.length;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t$slidee.append($element);\n\t\t\t}\n\n\t\t\t// Reload\n\t\t\tload();\n\t\t};\n\n\t\t/**\n\t\t * Remove an item from SLIDEE.\n\t\t *\n\t\t * @param {Mixed} element Item index, or DOM element.\n\t\t * @param {Int}   index   Index of a new item position. By default item is appended at the end.\n\t\t *\n\t\t * @return {Void}\n\t\t */\n\t\tself.remove = function (element) {\n\t\t\tif (itemNav) {\n\t\t\t\tvar index = getRelativeIndex(element);\n\n\t\t\t\tif (index > -1) {\n\t\t\t\t\t// Remove the element\n\t\t\t\t\t$items.eq(index).remove();\n\n\t\t\t\t\t// If the current item is being removed, activate new one after reload\n\t\t\t\t\tvar reactivate = index === rel.activeItem && !(forceCenteredNav && o.activateMiddle);\n\n\t\t\t\t\t// Adjust the activeItem index\n\t\t\t\t\tif (index < rel.activeItem || rel.activeItem >= items.length - 1) {\n\t\t\t\t\t\tlast.active = --rel.activeItem;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Reload\n\t\t\t\t\tload();\n\n\t\t\t\t\t// Activate new item at the removed position if the current active got removed\n\t\t\t\t\tif (reactivate) {\n\t\t\t\t\t\tself.activate(rel.activeItem);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t$(element).remove();\n\t\t\t\tload();\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Helps re-arranging items.\n\t\t *\n\t\t * @param  {Mixed} item     Item DOM element, or index starting at 0. Use negative numbers to select items from the end.\n\t\t * @param  {Mixed} position Item insertion anchor. Accepts same input types as item argument.\n\t\t * @param  {Bool}  after    Insert after instead of before the anchor.\n\t\t *\n\t\t * @return {Void}\n\t\t */\n\t\tfunction moveItem(item, position, after) {\n\t\t\titem = getRelativeIndex(item);\n\t\t\tposition = getRelativeIndex(position);\n\n\t\t\t// Move only if there is an actual change requested\n\t\t\tif (item > -1 && position > -1 && item !== position && (!after || position !== item - 1) && (after || position !== item + 1)) {\n\t\t\t\t$items.eq(item)[after ? 'insertAfter' : 'insertBefore'](items[position].el);\n\n\t\t\t\tvar shiftStart = item < position ? item : (after ? position : position - 1);\n\t\t\t\tvar shiftEnd = item > position ? item : (after ? position + 1 : position);\n\t\t\t\tvar shiftsUp = item > position;\n\n\t\t\t\t// Update activeItem index\n\t\t\t\tif (item === rel.activeItem) {\n\t\t\t\t\tlast.active = rel.activeItem = after ? (shiftsUp ? position + 1 : position) : (shiftsUp ? position : position - 1);\n\t\t\t\t} else if (rel.activeItem > shiftStart && rel.activeItem < shiftEnd) {\n\t\t\t\t\tlast.active = rel.activeItem += shiftsUp ? 1 : -1;\n\t\t\t\t}\n\n\t\t\t\t// Reload\n\t\t\t\tload();\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Move item after the target anchor.\n\t\t *\n\t\t * @param  {Mixed} item     Item to be moved. Can be DOM element or item index.\n\t\t * @param  {Mixed} position Target position anchor. Can be DOM element or item index.\n\t\t *\n\t\t * @return {Void}\n\t\t */\n\t\tself.moveAfter = function (item, position) {\n\t\t\tmoveItem(item, position, 1);\n\t\t};\n\n\t\t/**\n\t\t * Move item before the target anchor.\n\t\t *\n\t\t * @param  {Mixed} item     Item to be moved. Can be DOM element or item index.\n\t\t * @param  {Mixed} position Target position anchor. Can be DOM element or item index.\n\t\t *\n\t\t * @return {Void}\n\t\t */\n\t\tself.moveBefore = function (item, position) {\n\t\t\tmoveItem(item, position);\n\t\t};\n\n\t\t/**\n\t\t * Registers callbacks.\n\t\t *\n\t\t * @param  {Mixed} name  Event name, or callbacks map.\n\t\t * @param  {Mixed} fn    Callback, or an array of callback functions.\n\t\t *\n\t\t * @return {Void}\n\t\t */\n\t\tself.on = function (name, fn) {\n\t\t\t// Callbacks map\n\t\t\tif (type(name) === 'object') {\n\t\t\t\tfor (var key in name) {\n\t\t\t\t\tif (name.hasOwnProperty(key)) {\n\t\t\t\t\t\tself.on(key, name[key]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t// Callback\n\t\t\t} else if (type(fn) === 'function') {\n\t\t\t\tvar names = name.split(' ');\n\t\t\t\tfor (var n = 0, nl = names.length; n < nl; n++) {\n\t\t\t\t\tcallbacks[names[n]] = callbacks[names[n]] || [];\n\t\t\t\t\tif (callbackIndex(names[n], fn) === -1) {\n\t\t\t\t\t\tcallbacks[names[n]].push(fn);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t// Callbacks array\n\t\t\t} else if (type(fn) === 'array') {\n\t\t\t\tfor (var f = 0, fl = fn.length; f < fl; f++) {\n\t\t\t\t\tself.on(name, fn[f]);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Remove one or all callbacks.\n\t\t *\n\t\t * @param  {String} name Event name.\n\t\t * @param  {Mixed}  fn   Callback, or an array of callback functions. Omit to remove all callbacks.\n\t\t *\n\t\t * @return {Void}\n\t\t */\n\t\tself.off = function (name, fn) {\n\t\t\tif (fn instanceof Array) {\n\t\t\t\tfor (var f = 0, fl = fn.length; f < fl; f++) {\n\t\t\t\t\tself.off(name, fn[f]);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tvar names = name.split(' ');\n\t\t\t\tfor (var n = 0, nl = names.length; n < nl; n++) {\n\t\t\t\t\tcallbacks[names[n]] = callbacks[names[n]] || [];\n\t\t\t\t\tif (type(fn) === 'undefined') {\n\t\t\t\t\t\tcallbacks[names[n]].length = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar index = callbackIndex(names[n], fn);\n\t\t\t\t\t\tif (index !== -1) {\n\t\t\t\t\t\t\tcallbacks[names[n]].splice(index, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Returns callback array index.\n\t\t *\n\t\t * @param  {String}   name Event name.\n\t\t * @param  {Function} fn   Function\n\t\t *\n\t\t * @return {Int} Callback array index, or -1 if isn't registered.\n\t\t */\n\t\tfunction callbackIndex(name, fn) {\n\t\t\tfor (var i = 0, l = callbacks[name].length; i < l; i++) {\n\t\t\t\tif (callbacks[name][i] === fn) {\n\t\t\t\t\treturn i;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n\n\t\t/**\n\t\t * Reset next cycle timeout.\n\t\t *\n\t\t * @return {Void}\n\t\t */\n\t\tfunction resetCycle() {\n\t\t\tif (dragging.released && !self.isPaused) {\n\t\t\t\tself.resume();\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Calculate SLIDEE representation of handle position.\n\t\t *\n\t\t * @param  {Int} handlePos\n\t\t *\n\t\t * @return {Int}\n\t\t */\n\t\tfunction handleToSlidee(handlePos) {\n\t\t\treturn Math.round(within(handlePos, hPos.start, hPos.end) / hPos.end * (pos.end - pos.start)) + pos.start;\n\t\t}\n\n\t\t/**\n\t\t * Keeps track of a dragging delta history.\n\t\t *\n\t\t * @return {Void}\n\t\t */\n\t\tfunction draggingHistoryTick() {\n\t\t\t// Looking at this, I know what you're thinking :) But as we need only 4 history states, doing it this way\n\t\t\t// as opposed to a proper loop is ~25 bytes smaller (when minified with GCC), a lot faster, and doesn't\n\t\t\t// generate garbage. The loop version would create 2 new variables on every tick. Unexaptable!\n\t\t\tdragging.history[0] = dragging.history[1];\n\t\t\tdragging.history[1] = dragging.history[2];\n\t\t\tdragging.history[2] = dragging.history[3];\n\t\t\tdragging.history[3] = dragging.delta;\n\t\t}\n\n\t\t/**\n\t\t * Initialize continuous movement.\n\t\t *\n\t\t * @return {Void}\n\t\t */\n\t\tfunction continuousInit(source) {\n\t\t\tdragging.released = 0;\n\t\t\tdragging.source = source;\n\t\t\tdragging.slidee = source === 'slidee';\n\t\t}\n\n\t\t/**\n\t\t * Dragging initiator.\n\t\t *\n\t\t * @param  {Event} event\n\t\t *\n\t\t * @return {Void}\n\t\t */\n\t\tfunction dragInit(event) {\n\t\t\t// Ignore when already in progress\n\t\t\tif (dragging.init) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar isTouch = event.type === 'touchstart';\n\t\t\tvar source = event.data.source;\n\t\t\tvar isSlidee = source === 'slidee';\n\n\t\t\t// Handle dragging conditions\n\t\t\tif (source === 'handle' && (!o.dragHandle || hPos.start === hPos.end)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// SLIDEE dragging conditions\n\t\t\tif (isSlidee && !(isTouch ? o.touchDragging : o.mouseDragging && event.which < 2)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (!isTouch) {\n\t\t\t\tstopDefault(event, 1);\n\t\t\t}\n\n\t\t\t// Reset dragging object\n\t\t\tcontinuousInit(source);\n\n\t\t\t// Properties used in dragHandler\n\t\t\tdragging.$source = $(event.target);\n\t\t\tdragging.init = 0;\n\t\t\tdragging.touch = isTouch;\n\t\t\tdragging.pointer = isTouch ? event.originalEvent.touches[0] : event;\n\t\t\tdragging.initX = dragging.pointer.pageX;\n\t\t\tdragging.initY = dragging.pointer.pageY;\n\n\t\t\tdragging.initPos = isSlidee ? pos.cur : hPos.cur;\n\t\t\tdragging.start = +new Date();\n\t\t\tdragging.time = 0;\n\t\t\tdragging.path = 0;\n\t\t\tdragging.pathToInit = isSlidee ? isTouch ? 50 : 10 : 0;\n\t\t\tdragging.history = [0, 0, 0, 0];\n\t\t\tdragging.initLoc = dragging[o.horizontal ? 'initX' : 'initY'];\n\t\t\tdragging.deltaMin = isSlidee ? -dragging.initLoc : -hPos.cur;\n\t\t\tdragging.deltaMax = isSlidee ? document[o.horizontal ? 'width' : 'height'] - dragging.initLoc : hPos.end - hPos.cur;\n\n\t\t\t// Add dragging class\n\t\t\t(isSlidee ? $slidee : $handle).addClass(o.draggedClass);\n\n\t\t\t// Bind dragging events\n\t\t\t$doc.on(isTouch ? dragTouchEvents : dragMouseEvents, dragHandler);\n\n\t\t\t// Keep track of a dragging path history. This is later used in the\n\t\t\t// dragging release swing calculation when dragging SLIDEE.\n\t\t\tif (isSlidee) {\n\t\t\t\thistoryID = setInterval(draggingHistoryTick, 10);\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Handler for dragging scrollbar handle or SLIDEE.\n\t\t *\n\t\t * @param  {Event} event\n\t\t *\n\t\t * @return {Void}\n\t\t */\n\t\tfunction dragHandler(event) {\n\t\t\tdragging.released = event.type === 'mouseup' || event.type === 'touchend';\n\t\t\tdragging.pointer = dragging.touch ? event.originalEvent[dragging.released ? 'changedTouches' : 'touches'][0] : event;\n\t\t\tdragging.pathX = dragging.pointer.pageX - dragging.initX;\n\t\t\tdragging.pathY = dragging.pointer.pageY - dragging.initY;\n\t\t\tdragging.pathTotal = Math.sqrt(Math.pow(dragging.pathX, 2) + Math.pow(dragging.pathY, 2));\n\t\t\tdragging.delta = within(o.horizontal ? dragging.pathX : dragging.pathY, dragging.deltaMin, dragging.deltaMax);\n\n\t\t\t// Initialization\n\t\t\tif (!dragging.init && dragging.pathTotal > dragging.pathToInit) {\n\t\t\t\tif (dragging.slidee) {\n\t\t\t\t\t// If path has reached the pathToInit value, but in a wrong direction, cancel dragging\n\t\t\t\t\tif (o.horizontal ? Math.abs(dragging.pathX) < Math.abs(dragging.pathY) : Math.abs(dragging.pathX) > Math.abs(dragging.pathY)) {\n\t\t\t\t\t\tdragEnd();\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\t// Disable click on a source element, as it is unwelcome when dragging SLIDEE\n\t\t\t\t\tdragging.$source.on(clickEvent, disableOneEvent);\n\t\t\t\t}\n\t\t\t\t// Mark dragging as initiated\n\t\t\t\tdragging.init = 1;\n\t\t\t\t// Pause ongoing cycle\n\t\t\t\tself.pause(1);\n\t\t\t\t// Trigger moveStart event\n\t\t\t\ttrigger('moveStart');\n\t\t\t}\n\n\t\t\t// Proceed when initialized\n\t\t\tif (dragging.init) {\n\t\t\t\tif (dragging.released) {\n\t\t\t\t\tif (!dragging.touch) {\n\t\t\t\t\t\tstopDefault(event);\n\t\t\t\t\t}\n\n\t\t\t\t\tdragging.init = 0;\n\n\t\t\t\t\t// Adjust path with a swing on mouse release\n\t\t\t\t\tif (o.releaseSwing && dragging.slidee) {\n\t\t\t\t\t\tdragging.swing = (dragging.delta - dragging.history[0]) / 40 * 300;\n\t\t\t\t\t\tdragging.delta += dragging.swing;\n\t\t\t\t\t\tdragging.tweese = Math.abs(dragging.swing) > 10;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tstopDefault(event);\n\t\t\t\t}\n\n\t\t\t\tslideTo(dragging.slidee ? Math.round(dragging.initPos - dragging.delta) : handleToSlidee(dragging.initPos + dragging.delta));\n\t\t\t}\n\n\t\t\t// Stop and cleanup after dragging\n\t\t\tif (dragging.released) {\n\t\t\t\tdragEnd();\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Stops dragging and cleans up after it.\n\t\t *\n\t\t * @return {Void}\n\t\t */\n\t\tfunction dragEnd() {\n\t\t\tclearInterval(historyID);\n\t\t\t$doc.off(dragging.touch ? dragTouchEvents : dragMouseEvents, dragHandler);\n\t\t\t(dragging.slidee ? $slidee : $handle).removeClass(o.draggedClass);\n\n\t\t\t// Resume ongoing cycle\n\t\t\tself.resume(1);\n\n\t\t\t// Normally, this is triggered in render(), but if there\n\t\t\t// is nothing to render, we have to do it manually here.\n\t\t\tif (dragging.init && pos.cur === pos.dest) {\n\t\t\t\ttrigger('moveEnd');\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Continuous movement cleanup on mouseup.\n\t\t *\n\t\t * @return {Void}\n\t\t */\n\t\tfunction movementReleaseHandler() {\n\t\t\tself.stop();\n\t\t\t$doc.off('mouseup', movementReleaseHandler);\n\t\t}\n\n\t\t/**\n\t\t * Buttons navigation handler.\n\t\t *\n\t\t * @param  {Event} event\n\t\t *\n\t\t * @return {Void}\n\t\t */\n\t\tfunction buttonsHandler(event) {\n\t\t\t/*jshint validthis:true */\n\t\t\tstopDefault(event);\n\t\t\tswitch (this) {\n\t\t\t\tcase $forwardButton[0]:\n\t\t\t\tcase $backwardButton[0]:\n\t\t\t\t\tself.moveBy($forwardButton.is(this) ? o.moveBy : -o.moveBy);\n\t\t\t\t\t$doc.on('mouseup', movementReleaseHandler);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase $prevButton[0]:\n\t\t\t\t\tself.prev();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase $nextButton[0]:\n\t\t\t\t\tself.next();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase $prevPageButton[0]:\n\t\t\t\t\tself.prevPage();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase $nextPageButton[0]:\n\t\t\t\t\tself.nextPage();\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Mouse wheel delta normalization.\n\t\t *\n\t\t * @param  {Event} event\n\t\t *\n\t\t * @return {Int}\n\t\t */\n\t\tfunction normalizeWheelDelta(event) {\n\t\t\treturn within(-event.wheelDelta || event.detail, -1, 1);\n\t\t}\n\n\t\t/**\n\t\t * Mouse scrolling handler.\n\t\t *\n\t\t * @param  {Event} event\n\t\t *\n\t\t * @return {Void}\n\t\t */\n\t\tfunction scrollHandler(event) {\n\t\t\t// Ignore if there is no scrolling to be done\n\t\t\tif (!o.scrollBy || pos.start === pos.end) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tstopDefault(event, 1);\n\n\t\t\tvar delta = normalizeWheelDelta(event.originalEvent);\n\t\t\tif (itemNav) {\n\t\t\t\tself[centeredNav ? 'toCenter' : 'toStart'](\n\t\t\t\t\twithin((centeredNav ? rel.centerItem : rel.firstItem) + o.scrollBy * delta, 0, items.length)\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tself.slideBy(o.scrollBy * delta);\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Scrollbar click handler.\n\t\t *\n\t\t * @param  {Event} event\n\t\t *\n\t\t * @return {Void}\n\t\t */\n\t\tfunction scrollbarHandler(event) {\n\t\t\t// Only clicks on scroll bar. Ignore the handle.\n\t\t\tif (o.clickBar && event.target === $sb[0]) {\n\t\t\t\tstopDefault(event);\n\t\t\t\t// Calculate new handle position and sync SLIDEE to it\n\t\t\t\tslideTo(handleToSlidee((o.horizontal ? event.pageX - $sb.offset().left : event.pageY - $sb.offset().top) - handleSize / 2));\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Keyboard input handler.\n\t\t *\n\t\t * @param  {Event} event\n\t\t *\n\t\t * @return {Void}\n\t\t */\n\t\tfunction keyboardHandler(event) {\n\t\t\tif (!o.keyboardNavBy) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tswitch (event.which) {\n\t\t\t\t// Left or Up\n\t\t\t\tcase o.horizontal ? 37 : 38:\n\t\t\t\t\tstopDefault(event);\n\t\t\t\t\tself[o.keyboardNavBy === 'pages' ? 'prevPage' : 'prev']();\n\t\t\t\t\tbreak;\n\n\t\t\t\t// Right or Down\n\t\t\t\tcase o.horizontal ? 39 : 40:\n\t\t\t\t\tstopDefault(event);\n\t\t\t\t\tself[o.keyboardNavBy === 'pages' ? 'nextPage' : 'next']();\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Click on item activation handler.\n\t\t *\n\t\t * @param  {Event} event\n\t\t *\n\t\t * @return {Void}\n\t\t */\n\t\tfunction activateHandler() {\n\t\t\t/*jshint validthis:true */\n\t\t\t// Accept only events from direct SLIDEE children.\n\t\t\tif (this.parentNode === $slidee[0]) {\n\t\t\t\tself.activate(this);\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Click on page button handler.\n\t\t *\n\t\t * @param {Event} event\n\t\t *\n\t\t * @return {Void}\n\t\t */\n\t\tfunction activatePageHandler() {\n\t\t\t/*jshint validthis:true */\n\t\t\t// Accept only events from direct pages bar children.\n\t\t\tif (this.parentNode === $pb[0]) {\n\t\t\t\tself.activatePage($pages.index(this));\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Pause on hover handler.\n\t\t *\n\t\t * @param  {Event} event\n\t\t *\n\t\t * @return {Void}\n\t\t */\n\t\tfunction pauseOnHoverHandler(event) {\n\t\t\tif (o.pauseOnHover) {\n\t\t\t\tself[event.type === 'mouseenter' ? 'pause' : 'resume'](2);\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Trigger callbacks for event.\n\t\t *\n\t\t * @param  {String} name Event name.\n\t\t * @param  {Mixed}  argX Arguments passed to callbacks.\n\t\t *\n\t\t * @return {Void}\n\t\t */\n\t\tfunction trigger(name, arg1) {\n\t\t\tif (callbacks[name]) {\n\t\t\t\tfor (i = 0, l = callbacks[name].length; i < l; i++) {\n\t\t\t\t\tcallbacks[name][i].call(self, name, arg1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Destroys instance and everything it created.\n\t\t *\n\t\t * @return {Void}\n\t\t */\n\t\tself.destroy = function () {\n\t\t\t// Unbind all events\n\t\t\t$doc\n\t\t\t\t.add($scrollSource)\n\t\t\t\t.add($handle)\n\t\t\t\t.add($sb)\n\t\t\t\t.add($pb)\n\t\t\t\t.add($forwardButton)\n\t\t\t\t.add($backwardButton)\n\t\t\t\t.add($prevButton)\n\t\t\t\t.add($nextButton)\n\t\t\t\t.add($prevPageButton)\n\t\t\t\t.add($nextPageButton)\n\t\t\t\t.unbind('.' + namespace);\n\n\t\t\t// Remove classes\n\t\t\t$prevButton\n\t\t\t\t.add($nextButton)\n\t\t\t\t.add($prevPageButton)\n\t\t\t\t.add($nextPageButton)\n\t\t\t\t.removeClass(o.disabledClass);\n\n\t\t\tif ($items) {\n\t\t\t\t$items.eq(rel.activeItem).removeClass(o.activeClass);\n\t\t\t}\n\n\t\t\t// Remove page items\n\t\t\t$pb.empty();\n\n\t\t\tif (!parallax) {\n\t\t\t\t// Unbind events from frame\n\t\t\t\t$frame.unbind('.' + namespace);\n\t\t\t\t// Reset SLIDEE and handle positions\n\t\t\t\t$slidee.add($handle).css(transform || (o.horizontal ? 'left' : 'top'), transform ? 'none' : 0);\n\t\t\t\t// Remove the instance from element data storage\n\t\t\t\t$.removeData(frame, namespace);\n\t\t\t}\n\n\t\t\t// Reset initialized status and return the instance\n\t\t\tinitialized = 0;\n\t\t\treturn self;\n\t\t};\n\n\t\t/**\n\t\t * Initialize.\n\t\t *\n\t\t * @return {Object}\n\t\t */\n\t\tself.init = function () {\n\t\t\tif (initialized) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Register callbacks map\n\t\t\tself.on(callbackMap);\n\n\t\t\t// Set required styles\n\t\t\tvar $movables = $handle;\n\t\t\tif (!parallax) {\n\t\t\t\t$movables = $movables.add($slidee);\n//\t\t\t\t$frame.css('overflow', 'hidden');\n\t\t\t\tif (!transform && $frame.css('position') === 'static') {\n\t\t\t\t\t$frame.css('position', 'relative');\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (transform) {\n\t\t\t\tif (gpuAcceleration) {\n\t\t\t\t\t$movables.css(transform, gpuAcceleration);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif ($sb.css('position') === 'static') {\n\t\t\t\t\t$sb.css('position', 'relative');\n\t\t\t\t}\n\t\t\t\t$movables.css({ position: 'absolute' });\n\t\t\t}\n\n\t\t\t// Navigation buttons\n\t\t\tif (o.forward) {\n\t\t\t\t$forwardButton.on(mouseDownEvent, buttonsHandler);\n\t\t\t}\n\t\t\tif (o.backward) {\n\t\t\t\t$backwardButton.on(mouseDownEvent, buttonsHandler);\n\t\t\t}\n\t\t\tif (o.prev) {\n\t\t\t\t$prevButton.on(clickEvent, buttonsHandler);\n\t\t\t}\n\t\t\tif (o.next) {\n\t\t\t\t$nextButton.on(clickEvent, buttonsHandler);\n\t\t\t}\n\t\t\tif (o.prevPage) {\n\t\t\t\t$prevPageButton.on(clickEvent, buttonsHandler);\n\t\t\t}\n\t\t\tif (o.nextPage) {\n\t\t\t\t$nextPageButton.on(clickEvent, buttonsHandler);\n\t\t\t}\n\n\t\t\t// Scrolling navigation\n\t\t\t$scrollSource.on('DOMMouseScroll.' + namespace + ' mousewheel.' + namespace, scrollHandler);\n\n\t\t\t// Clicking on scrollbar navigation\n\t\t\tif ($sb[0]) {\n\t\t\t\t$sb.on(clickEvent, scrollbarHandler);\n\t\t\t}\n\n\t\t\t// Click on items navigation\n\t\t\tif (itemNav && o.activateOn) {\n\t\t\t\t$frame.on(o.activateOn + '.' + namespace, '*', activateHandler);\n\t\t\t}\n\n\t\t\t// Pages navigation\n\t\t\tif ($pb[0] && o.activatePageOn) {\n\t\t\t\t$pb.on(o.activatePageOn + '.' + namespace, '*', activatePageHandler);\n\t\t\t}\n\n\t\t\t// Dragging navigation\n\t\t\t$dragSource.on(dragInitEvents, { source: 'slidee' }, dragInit);\n\n\t\t\t// Scrollbar dragging navigation\n\t\t\tif ($handle) {\n\t\t\t\t$handle.on(dragInitEvents, { source: 'handle' }, dragInit);\n\t\t\t}\n\n\t\t\t// Keyboard navigation\n\t\t\t$doc.bind('keydown.' + namespace, keyboardHandler);\n\n\t\t\tif (!parallax) {\n\t\t\t\t// Pause on hover\n\t\t\t\t$frame.on('mouseenter.' + namespace + ' mouseleave.' + namespace, pauseOnHoverHandler);\n\t\t\t\t// Reset native FRAME element scroll\n\t\t\t\t$frame.on('scroll.' + namespace, resetScroll);\n\t\t\t}\n\n\t\t\t// Load\n\t\t\tload();\n\n\t\t\t// Activate requested position\n\t\t\tif (itemNav) {\n\t\t\t\tactivate(o.startAt);\n\t\t\t\tself[centeredNav ? 'toCenter' : 'toStart'](o.startAt);\n\t\t\t} else {\n\t\t\t\tslideTo(o.startAt, 1);\n\t\t\t}\n\n\t\t\t// Initiate automatic cycling\n\t\t\tif (o.cycleBy && !parallax) {\n\t\t\t\tself[o.startPaused ? 'pause' : 'resume']();\n\t\t\t}\n\n\t\t\t// Mark instance as initialized\n\t\t\tinitialized = 1;\n\n\t\t\t// Return instance\n\t\t\treturn self;\n\t\t};\n\t}\n\n\t/**\n\t * Return type of the value.\n\t *\n\t * @param  {Mixed} value\n\t *\n\t * @return {String}\n\t */\n\tfunction type(value) {\n\t\tif (value == null) {\n\t\t\treturn String(value);\n\t\t}\n\n\t\tif (typeof value === 'object' || typeof value === 'function') {\n\t\t\treturn Object.prototype.toString.call(value).match(/\\s([a-z]+)/i)[1].toLowerCase() || 'object';\n\t\t}\n\n\t\treturn typeof value;\n\t}\n\n\t/**\n\t * Event preventDefault & stopPropagation helper.\n\t *\n\t * @param {Event} event     Event object.\n\t * @param {Bool}  noBubbles Cancel event bubbling.\n\t *\n\t * @return {Void}\n\t */\n\tfunction stopDefault(event, noBubbles) {\n\t\tevent.preventDefault();\n\t\tif (noBubbles) {\n\t\t\tevent.stopPropagation();\n\t\t}\n\t}\n\n\t/**\n\t * Disables an event it was triggered on and unbinds itself.\n\t *\n\t * @param  {Event} event\n\t *\n\t * @return {Void}\n\t */\n\tfunction disableOneEvent(event) {\n\t\t/*jshint validthis:true */\n\t\tstopDefault(event, 1);\n\t\t$(this).off(event.type, disableOneEvent);\n\t}\n\n\t/**\n\t * Resets native element scroll values to 0.\n\t *\n\t * @return {Void}\n\t */\n\tfunction resetScroll() {\n\t\t/*jshint validthis:true */\n\t\tthis.scrollLeft = 0;\n\t\tthis.scrollTop = 0;\n\t}\n\n\t/**\n\t * Check if variable is a number.\n\t *\n\t * @param {Mixed} value\n\t *\n\t * @return {Boolean}\n\t */\n\tfunction isNumber(value) {\n\t\treturn !isNaN(parseFloat(value)) && isFinite(value);\n\t}\n\n\t/**\n\t * Parse style to pixels.\n\t *\n\t * @param {Object}   $item    jQuery object with element.\n\t * @param {Property} property CSS property to get the pixels from.\n\t *\n\t * @return {Int}\n\t */\n\tfunction getPx($item, property) {\n\t\treturn parseInt($item.css(property), 10) || 0;\n\t}\n\n\t/**\n\t * Make sure that number is within the limits.\n\t *\n\t * @param {Number} number\n\t * @param {Number} min\n\t * @param {Number} max\n\t *\n\t * @return {Number}\n\t */\n\tfunction within(number, min, max) {\n\t\treturn number < min ? min : number > max ? max : number;\n\t}\n\n\t// Local WindowAnimationTiming interface polyfill\n\t(function (w) {\n\t\tvar vendors = ['moz', 'webkit', 'o'];\n\t\tvar lastTime = 0;\n\n\t\t// For a more accurate WindowAnimationTiming interface implementation, ditch the native\n\t\t// requestAnimationFrame when cancelAnimationFrame is not present (older versions of Firefox)\n\t\tfor(var i = 0, l = vendors.length; i < l && !cAF; ++i) {\n\t\t\tcAF = w[vendors[i]+'CancelAnimationFrame'] || w[vendors[i]+'CancelRequestAnimationFrame'];\n\t\t\trAF = cAF && w[vendors[i]+'RequestAnimationFrame'];\n\t\t}\n\n\t\tif (!cAF) {\n\t\t\trAF = function (callback) {\n\t\t\t\tvar currTime = +new Date();\n\t\t\t\tvar timeToCall = Math.max(0, 16 - (currTime - lastTime));\n\t\t\t\tlastTime = currTime + timeToCall;\n\t\t\t\treturn w.setTimeout(function () { callback(currTime + timeToCall); }, timeToCall);\n\t\t\t};\n\n\t\t\tcAF = function (id) {\n\t\t\t\tclearTimeout(id);\n\t\t\t};\n\t\t}\n\t}(window));\n\n\t// Feature detects\n\t(function () {\n\t\tvar prefixes = ['', 'webkit', 'moz', 'ms', 'o'];\n\t\tvar el = document.createElement('div');\n\n\t\tfunction testProp(prop) {\n\t\t\tfor (var p = 0, pl = prefixes.length; p < pl; p++) {\n\t\t\t\tvar prefixedProp = prefixes[p] ? prefixes[p] + prop.charAt(0).toUpperCase() + prop.slice(1) : prop;\n\t\t\t\tif (el.style[prefixedProp] !== undefined) {\n\t\t\t\t\treturn prefixedProp;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Global support indicators\n\t\ttransform = testProp('transform');\n\t\tgpuAcceleration = testProp('perspective') ? 'translateZ(0) ' : '';\n\t}());\n\n\t// Expose class globally\n\tw[className] = Sly;\n\n\t// jQuery proxy\n\t$.fn[pluginName] = function (options, callbackMap) {\n\t\tvar method, methodArgs;\n\n\t\t// Attributes logic\n\t\tif (!$.isPlainObject(options)) {\n\t\t\tif (type(options) === 'string' || options === false) {\n\t\t\t\tmethod = options === false ? 'destroy' : options;\n\t\t\t\tmethodArgs = Array.prototype.slice.call(arguments, 1);\n\t\t\t}\n\t\t\toptions = {};\n\t\t}\n\n\t\t// Apply to all elements\n\t\treturn this.each(function (i, element) {\n\t\t\t// Call with prevention against multiple instantiations\n\t\t\tvar plugin = $.data(element, namespace);\n\n\t\t\tif (!plugin && !method) {\n\t\t\t\t// Create a new object if it doesn't exist yet\n\t\t\t\tplugin = $.data(element, namespace, new Sly(element, options, callbackMap).init());\n\t\t\t} else if (plugin && method) {\n\t\t\t\t// Call method\n\t\t\t\tif (plugin[method]) {\n\t\t\t\t\tplugin[method].apply(plugin, methodArgs);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t};\n\n\t// Default options\n\tSly.defaults = {\n\t\thorizontal: 0, // Switch to horizontal mode.\n\n\t\t// Item based navigation\n\t\titemNav:      null, // Item navigation type. Can be: 'basic', 'centered', 'forceCentered'.\n\t\titemSelector: null, // Select only items that match this selector.\n\t\tsmart:        0,    // Repositions the activated item to help with further navigation.\n\t\tactivateOn:   null, // Activate an item on this event. Can be: 'click', 'mouseenter', ...\n\t\tactivateMiddle: 0,  // Always activate the item in the middle of the FRAME. forceCentered only.\n\n\t\t// Scrolling\n\t\tscrollSource: null, // Element for catching the mouse wheel scrolling. Default is FRAME.\n\t\tscrollBy:     0,    // Pixels or items to move per one mouse scroll. 0 to disable scrolling.\n\n\t\t// Dragging\n\t\tdragSource:    null, // Selector or DOM element for catching dragging events. Default is FRAME.\n\t\tmouseDragging: 0,    // Enable navigation by dragging the SLIDEE with mouse cursor.\n\t\ttouchDragging: 0,    // Enable navigation by dragging the SLIDEE with touch events.\n\t\treleaseSwing:  0,    // Ease out on dragging swing release.\n\t\tswingSpeed:    0.2,  // Swing synchronization speed, where: 1 = instant, 0 = infinite.\n\t\telasticBounds: 0,    // Stretch SLIDEE position limits when dragging past FRAME boundaries.\n\n\t\t// Scrollbar\n\t\tscrollBar:     null, // Selector or DOM element for scrollbar container.\n\t\tdragHandle:    0,    // Whether the scrollbar handle should be draggable.\n\t\tdynamicHandle: 0,    // Scrollbar handle represents the ratio between hidden and visible content.\n\t\tminHandleSize: 50,   // Minimal height or width (depends on sly direction) of a handle in pixels.\n\t\tclickBar:      0,    // Enable navigation by clicking on scrollbar.\n\t\tsyncSpeed:     0.5,  // Handle => SLIDEE synchronization speed, where: 1 = instant, 0 = infinite.\n\n\t\t// Pagesbar\n\t\tpagesBar:       null, // Selector or DOM element for pages bar container.\n\t\tactivatePageOn: null, // Event used to activate page. Can be: click, mouseenter, ...\n\t\tpageBuilder:          // Page item generator.\n\t\t\tfunction (index) {\n\t\t\t\treturn '<li>' + (index + 1) + '</li>';\n\t\t\t},\n\n\t\t// Navigation buttons\n\t\tforward:  null, // Selector or DOM element for \"forward movement\" button.\n\t\tbackward: null, // Selector or DOM element for \"backward movement\" button.\n\t\tprev:     null, // Selector or DOM element for \"previous item\" button.\n\t\tnext:     null, // Selector or DOM element for \"next item\" button.\n\t\tprevPage: null, // Selector or DOM element for \"previous page\" button.\n\t\tnextPage: null, // Selector or DOM element for \"next page\" button.\n\n\t\t// Automated cycling\n\t\tcycleBy:       null, // Enable automatic cycling by 'items' or 'pages'.\n\t\tcycleInterval: 5000, // Delay between cycles in milliseconds.\n\t\tpauseOnHover:  0,    // Pause cycling when mouse hovers over the FRAME.\n\t\tstartPaused:   0,    // Whether to start in paused sate.\n\n\t\t// Mixed options\n\t\tmoveBy:        300,     // Speed in pixels per second used by forward and backward buttons.\n\t\tspeed:         0,       // Animations speed in milliseconds. 0 to disable animations.\n\t\teasing:        'swing', // Easing for duration based (tweening) animations.\n\t\tstartAt:       0,       // Starting offset in pixels or items.\n\t\tkeyboardNavBy: null,    // Enable keyboard navigation by 'items' or 'pages'.\n\n\t\t// Classes\n\t\tdraggedClass:  'dragged',  // Class for dragged elements (like SLIDEE or scrollbar handle).\n\t\tactiveClass:   'active',   // Class for active items and pages.\n\t\tdisabledClass: 'disabled'  // Class for disabled navigation elements.\n\t};\n}(jQuery, window));\n"]],"start1":0,"start2":0,"length1":0,"length2":54049}]],"length":54049}
